
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module TSSemanticsBSemanticsSimplequiv</title>
<meta name="description" content="Documentation of Coq module TSSemanticsBSemanticsSimplequiv" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module TSSemanticsBSemanticsSimplequiv</h1>
<div class="coq">
<span class="kwd">From</span> <span class="id">compcert.lib</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span> <span class="id">Coqlib</span> <span class="id">Maps</span>.<br/>
<span class="kwd">From</span> <span class="id">compcert.common</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Values</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Memory</span> <span class="id">Memtype</span>.<br/>
<span class="kwd">From</span> <span class="id">compcert.cfrontend</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Ctypes</span>.<br/>
<span class="kwd">From</span> <span class="id">compcert.backend</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Locations</span>.<br/>
<span class="kwd">From</span> <span class="id">compcert.arm</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ABinSem</span> <span class="id">AsmSyntax</span> <span class="id">BinDecode</span>.<br/>
<span class="kwd">From</span> <span class="id">Coq</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ZArith</span> <span class="id">Lia</span> <span class="id">List</span>.<br/>
<br/>
<span class="kwd">From</span> <span class="id">bpf.comm</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Flag</span> <span class="id">Regs</span> <span class="id">MemRegion</span> <span class="id">ListAsArray</span> <span class="id">LemmaInt</span> <span class="id">JITCall</span>.<br/>
<span class="kwd">From</span> <span class="id">bpf.rbpf32</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">TSSyntax</span> <span class="id">TSDecode</span> <span class="id">Analyzer</span> <span class="id">JITConfig</span> <span class="id">BSemanticsSimpl</span>.<br/>
<span class="kwd">From</span> <span class="id">bpf.jit</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">TSSemanticsB</span> <span class="id">WholeCompiler</span> <span class="id">TSSemanticsBproofdef</span> <span class="id">TSSemanticsBproof</span>.<br/>
<br/>
<span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">asm</span>.<br/>
<span class="kwd">Import</span> <span class="id">ListNotations</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">memory_region_mapping</span> (<span class="id">mrs</span>: <span class="id">list</span> <span class="id">memory_region</span>) (<span class="id">m</span>: <span class="id">mem</span>) (<span class="id">p</span>: <span class="id">permission</span>) (<span class="id">ck</span>: <span class="id">memory_chunk</span>) (<span class="id">addr</span>: <span class="id">val</span>) (<span class="id">b</span>: <span class="id">block</span>) (<span class="id">ofs</span>: <span class="id">ptrofs</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">check_mem</span> <span class="id">p</span> <span class="id">ck</span> <span class="id">addr</span> (<span class="id">List.length</span> <span class="id">mrs</span>) <span class="id">mrs</span> <span class="id">m</span> = <span class="id">Some</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>).<br/>
<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">kv_flatten_aux</span> (<span class="id">kv</span>: <span class="id">list</span> (<span class="id">nat</span> * <span class="id">nat</span>)) (<span class="id">l</span>: <span class="id">list</span> <span class="id">nat</span>): <span class="id">list</span> <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">kv</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [] =&gt; <span class="id">l</span><br/>
&nbsp;&nbsp;| (<span class="id">k</span>, <span class="id">v</span>) :: <span class="id">tl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ListNat.assign</span> <span class="id">l</span> <span class="id">k</span> <span class="id">v</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">l</span>' =&gt; <span class="id">kv_flatten_aux</span> <span class="id">tl</span> <span class="id">l</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kv_flatten</span> (<span class="id">kv</span>: <span class="id">list</span> (<span class="id">nat</span> * <span class="id">nat</span>)) (<span class="id">len</span>: <span class="id">nat</span>): <span class="id">list</span> <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id">kv_flatten_aux</span> <span class="id">kv</span> (<span class="id">ListNat.create_int_list</span> <span class="id">len</span>).<br/>
<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">kv_flatten_property</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">c</span> <span class="id">kl</span> <span class="id">bl</span> <span class="id">kv</span> <span class="id">l</span> <span class="id">v_pc</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m1</span><br/>
&nbsp;&nbsp;(<span class="id">Hkv_ofs</span> : <span class="id">ListNat.index</span> (<span class="id">kv_flatten</span> <span class="id">kv</span> (<span class="id">Datatypes.length</span> <span class="id">c</span>)) (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>)) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;(<span class="id">Hsubst</span> : <span class="id">code_subset_in_blk</span> <span class="id">l</span> 0 <span class="id">jit_blk</span> <span class="id">m1</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;(<span class="id">Hlen_max</span> : <span class="id">Datatypes.length</span> <span class="id">c</span> &lt;= <span class="id">MAX_BPF_LIST_INPUT</span>)<br/>
&nbsp;&nbsp;(<span class="id">Hanalyzer</span> : <span class="id">analyzer</span> <span class="id">c</span> = <span class="id">Some</span> <span class="id">kl</span>)<br/>
&nbsp;&nbsp;(<span class="id">Hcombiner</span> : <span class="id">combiner</span> <span class="id">kl</span> = <span class="id">Some</span> <span class="id">bl</span>)<br/>
&nbsp;&nbsp;(<span class="id">Hconcat</span> : <span class="id">concat_bin</span> <span class="id">bl</span> = (<span class="id">kv</span>, <span class="id">l</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exists</span> <span class="id">nl</span> : <span class="id">bin_code</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>), (<span class="id">ofs</span>, <span class="id">nl</span>)) <span class="id">bl</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m1</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</div>
<div class="proofscript" id="proof1">
&nbsp;&nbsp;<span class="comment">(**r&nbsp;this&nbsp;is&nbsp;a&nbsp;property&nbsp;of&nbsp;kv_flatten,&nbsp;do&nbsp;it&nbsp;later&nbsp;*)</span><br/>
Admitted.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_state_pc</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v0</span> <span class="id">v1</span> <span class="id">m2</span>  <span class="id">ars1</span> <span class="id">astk1</span> <span class="id">astkb1</span> <span class="id">am</span><br/>
&nbsp;&nbsp;(<span class="id">Hinit</span>: <span class="id">init_state</span> <span class="id">compcertbin_signature</span> <span class="id">stack_block_size</span> <span class="id">Ptrofs.zero</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">v0</span>; <span class="id">v1</span>] <span class="id">m2</span> = <span class="id">ANext</span> <span class="id">ars1</span> <span class="id">astk1</span> <span class="id">astkb1</span> <span class="id">am</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ars1</span>#<span class="id">PC</span> = <span class="id">Cval</span> <span class="id">v0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</div>
<div class="proofscript" id="proof2">
&nbsp;&nbsp;<span class="comment">(**r&nbsp;unfold&nbsp;init_state&nbsp;imply&nbsp;the&nbsp;result&nbsp;*)</span><br/>
Admitted.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">code_subset_in_blk_alloc_unchanged</span>:<br/>
<span class="kwd">forall</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m1</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">m</span> <span class="id">x</span> <span class="id">y</span> = (<span class="id">m1</span>, <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m1</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</div>
<div class="proofscript" id="proof3">
<br/>
Admitted.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">code_subset_in_blk_copy_to_unchanged</span>:<br/>
<span class="kwd">forall</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m</span> <span class="id">b</span> <span class="id">m1</span> <span class="id">rs</span>,<br/>
&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">copy_to</span> <span class="id">rs</span> <span class="id">b</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">m1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m1</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</div>
<div class="proofscript" id="proof4">
<br/>
Admitted.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">code_subset_in_blk_init_state_unchanged</span>:<br/>
<span class="kwd">forall</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m</span> <span class="id">v0</span> <span class="id">v1</span> <span class="id">ars1</span> <span class="id">astk1</span> <span class="id">astkb1</span> <span class="id">m1</span>,<br/>
&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">init_state</span> <span class="id">compcertbin_signature</span> <span class="id">stack_block_size</span> <span class="id">Ptrofs.zero</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">v0</span>; <span class="id">v1</span>] <span class="id">m</span> = <span class="id">ANext</span> <span class="id">ars1</span> <span class="id">astk1</span> <span class="id">astkb1</span> <span class="id">m1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m1</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</div>
<div class="proofscript" id="proof5">
<br/>
Admitted.</div>
<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">bin_interp_less_fuel</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">rt</span> <span class="id">k</span> <span class="id">ars2</span> <span class="id">stk2</span> <span class="id">stkb2</span> <span class="id">m1</span> <span class="id">res</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">bin_interp</span> <span class="id">rt</span> <span class="id">n</span> <span class="id">ars2</span> <span class="id">stk2</span> <span class="id">stkb2</span> <span class="id">m1</span> = <span class="id">Some</span> (<span class="id">res</span>, <span class="id">m2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">n</span> &lt;= <span class="id">k</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bin_interp</span> <span class="id">rt</span> <span class="id">k</span> <span class="id">ars2</span> <span class="id">stk2</span> <span class="id">stkb2</span> <span class="id">m1</span> = <span class="id">Some</span> (<span class="id">res</span>, <span class="id">m2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</div>
<div class="proofscript" id="proof6">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">n</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">k</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">is_final_state</span>; [| <span class="tactic">inversion</span> <span class="id">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">is_final_state</span> <span class="id">eqn</span>: <span class="id">Hfinal</span>.<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(**r&nbsp;is&nbsp;final&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">k</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">inversion</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hfinal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="comment">(**r&nbsp;is&nbsp;NOT&nbsp;final&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ABinSem.find_instr</span> <span class="kwd">as</span> [ (<span class="id">i</span> &amp; <span class="id">sz</span>) | ] <span class="id">eqn</span>: <span class="id">Hfind</span>;<br/>
&nbsp;&nbsp;[| <span class="tactic">inversion</span> <span class="id">H</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">aexec_instr</span> <span class="kwd">as</span> [ <span class="id">rs</span>' <span class="id">stk</span>' <span class="id">stkb</span> <span class="id">m</span>' | ] <span class="id">eqn</span>: <span class="id">Hexe</span>;<br/>
&nbsp;&nbsp;[| <span class="tactic">inversion</span> <span class="id">H</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">k</span>; [<span class="tactic">inversion</span> <span class="id">H0</span> |].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Heq</span>: <span class="id">n</span> &lt;= <span class="id">k</span>) <span class="tactic">by</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hfinal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hfind</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hexe</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHn</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Axiom</span> <span class="id">check_mem_prop</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">ck</span> <span class="id">addr</span> <span class="id">n</span> <span class="id">mrs</span> <span class="id">m</span> <span class="id">ptr</span>,<br/>
&nbsp;&nbsp;<span class="id">check_mem</span> <span class="id">p</span> <span class="id">ck</span> <span class="id">addr</span> <span class="id">n</span> <span class="id">mrs</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">ptr</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="tactic">exists</span> <span class="id">b</span> <span class="id">ofs</span>, <span class="id">ptr</span> = <span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.valid_pointer</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id">Mem.valid_pointer</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> - 1) = <span class="id">true</span>)%<span class="id">bool</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/ <span class="id">ptr</span> = <span class="id">Vnullptr</span>.<br/>
<br/>
<br/>
<span class="kwd">Axiom</span> <span class="id">aexec_instr_inv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sz</span> <span class="id">i</span> (<span class="id">rs0</span> <span class="id">rs1</span>: <span class="id">aregset</span>) <span class="id">stk</span> <span class="id">stkb</span> <span class="id">m0</span> <span class="id">stk1</span> <span class="id">stkb1</span> <span class="id">m1</span> <span class="id">jit_blk</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs0</span>#<span class="id">PC</span> = <span class="id">Cval</span> (<span class="id">Vptr</span> <span class="id">jit_blk</span> (<span class="id">Ptrofs.of_int</span> (<span class="id">Int.repr</span> (<span class="id">Z.of_nat</span> <span class="id">ofs</span>)))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">aexec_instr</span> <span class="id">sz</span> <span class="id">i</span> <span class="id">rs0</span> <span class="id">stk</span> <span class="id">stkb</span> <span class="id">m0</span> = <span class="id">ANext</span> <span class="id">rs1</span> <span class="id">stk1</span> <span class="id">stkb1</span> <span class="id">m1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs1</span>#<span class="id">PC</span> = <span class="id">Cval</span> (<span class="id">Vptr</span> <span class="id">jit_blk</span> (<span class="id">Ptrofs.of_int</span> (<span class="id">Int.repr</span> (<span class="id">Z.of_nat</span> (<span class="id">ofs</span> + 4))))) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">Z.of_nat</span> <span class="id">ofs</span>+4) &lt;= <span class="id">Ptrofs.max_unsigned</span>)%<span class="id">Z</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.unchanged_on</span> (<span class="kwd">fun</span> (<span class="id">b</span> : <span class="id">block</span>) (<span class="id">_</span> : <span class="id">Z</span>) =&gt; <span class="id">b</span> = <span class="id">jit_blk</span>) <span class="id">m0</span> <span class="id">m1</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">code_subset_in_blk_unchange</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m5</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;(<span class="id">Hsubst</span> : <span class="id">code_subset_in_blk</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m5</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;(<span class="id">Hunchanged</span> : <span class="id">Mem.unchanged_on</span> (<span class="kwd">fun</span> (<span class="id">b</span> : <span class="id">block</span>) (<span class="id">_</span> : <span class="id">Z</span>) =&gt; <span class="id">b</span> = <span class="id">jit_blk</span>) <span class="id">m5</span> <span class="id">m</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m</span>' = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</div>
<div class="proofscript" id="proof7">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">nl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">reflexivity</span>. }<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Mem.load</span> <span class="id">eqn</span>: <span class="id">Hload</span> <span class="kwd">in</span> <span class="id">Hsubst</span>; [| <span class="tactic">inversion</span> <span class="id">Hsubst</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">inversion</span> <span class="id">Hsubst</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hsubst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_unchanged_on_1</span> <span class="kwd">with</span> (<span class="id">chunk</span> := <span class="id">Mint32</span>) (<span class="id">ofs</span> := (<span class="id">Z.of_nat</span> <span class="id">ofs</span>)) <span class="kwd">in</span> <span class="id">Hunchanged</span> <span class="kwd">as</span> <span class="id">Heq</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;2:{ <span class="tactic">eapply</span> <span class="id">Mem.load_valid_access</span> <span class="kwd">in</span> <span class="id">Hload</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.valid_access_valid_block</span> <span class="kwd">with</span> (<span class="id">chunk</span> := <span class="id">Mint32</span>) (<span class="id">ofs</span> := (<span class="id">Z.of_nat</span> <span class="id">ofs</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.valid_access_implies</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">constructor</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Int.eq</span>; [| <span class="tactic">inversion</span> <span class="id">Hsubst</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHnl</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bin_interp_exec_bin_list</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m5</span> <span class="id">rs</span> <span class="id">stk</span> <span class="id">stkb</span> <span class="id">res</span> <span class="id">m6</span><br/>
&nbsp;&nbsp;(<span class="id">Hsubst</span>: <span class="id">code_subset_in_blk</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m5</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;(<span class="id">Hpc</span>: <span class="id">rs</span>#<span class="id">PC</span> = <span class="id">Cval</span> (<span class="id">Vptr</span> <span class="id">jit_blk</span> (<span class="id">Ptrofs.of_int</span> (<span class="id">Int.repr</span> (<span class="id">Z.of_nat</span> <span class="id">ofs</span>)))))<br/>
&nbsp;&nbsp;(<span class="id">Hinterp</span>: <span class="id">bin_interp</span> (<span class="id">sig_res</span> <span class="id">compcertbin_signature</span>) (<span class="id">List.length</span> <span class="id">nl</span>) <span class="id">rs</span> <span class="id">stk</span> <span class="id">stkb</span> <span class="id">m5</span> = <span class="id">Some</span> (<span class="id">res</span>, <span class="id">m6</span>)),<br/>
&nbsp;&nbsp;<span class="tactic">exists</span> <span class="id">rs1</span> <span class="id">stk1</span> <span class="id">stkb1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_bin_list</span> <span class="id">nl</span> <span class="id">rs</span> <span class="id">stk</span> <span class="id">stkb</span> <span class="id">m5</span> = <span class="id">ANext</span> <span class="id">rs1</span> <span class="id">stk1</span> <span class="id">stkb1</span> <span class="id">m6</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_final_state</span> <span class="id">rs1</span> = <span class="id">true</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get_result_bool</span> <span class="id">AST.Tint</span> (<span class="id">rs1</span> <span class="id">IR0</span>) = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</div>
<div class="proofscript" id="proof8">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">nl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">exists</span> <span class="id">rs</span>, <span class="id">stk</span>, <span class="id">stkb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">is_final_state</span> <span class="id">eqn</span>: <span class="id">Hfinal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">get_result</span> <span class="kwd">in</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">get_result_bool</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rs</span> <span class="id">IR0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">_</span> &amp;&amp; <span class="id">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">inversion</span> <span class="id">Hinterp</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">inversion</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">inversion</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">inversion</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Mem.load</span> <span class="kwd">as</span> [<span class="id">ins</span> | ] <span class="id">eqn</span>: <span class="id">Hload_ins</span>; [| <span class="tactic">inversion</span> <span class="id">Hsubst</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ins</span>; <span class="tactic">inversion</span> <span class="id">Hsubst</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hsubst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ABinSem.find_instr</span> <span class="kwd">in</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">BinDecode.find_instr</span> <span class="kwd">in</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">is_final_state</span> <span class="id">eqn</span>: <span class="id">Hfinal</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">get_result</span> <span class="kwd">in</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">get_result_bool</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exists</span> <span class="id">rs</span>, <span class="id">stk</span>, <span class="id">stkb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rs</span> <span class="id">IR0</span>); [| <span class="tactic">inversion</span> <span class="id">Hinterp</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">_</span> &amp;&amp; <span class="id">_</span>); [| <span class="tactic">inversion</span> <span class="id">Hinterp</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hinterp</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hpc</span> <span class="kwd">in</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Hinterp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Mem.load</span> <span class="id">eqn</span>: <span class="id">Hload</span> <span class="kwd">in</span> <span class="id">Hinterp</span>; [| <span class="tactic">inversion</span> <span class="id">Hinterp</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">inversion</span> <span class="id">Hinterp</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">option_map</span> <span class="kwd">as</span> [(<span class="id">ins</span> &amp; <span class="id">sz</span>)|] <span class="id">eqn</span>: <span class="id">Hdecode_op</span>; [| <span class="tactic">inversion</span> <span class="id">Hinterp</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">aexec_instr</span> <span class="kwd">as</span> [ <span class="id">rs</span>' <span class="id">stk</span>' <span class="id">stkb</span>' <span class="id">m</span>' |] <span class="id">eqn</span>: <span class="id">Hexe</span>; [| <span class="tactic">inversion</span> <span class="id">Hinterp</span>].<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">aexec_instr_inv</span> <span class="kwd">in</span> <span class="id">Hpc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hpc</span> <span class="kwd">as</span> (<span class="id">Hpc1</span> &amp; <span class="id">Hpc_max</span> &amp; <span class="id">Hunchanged</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Ptrofs.of_int</span> <span class="kwd">in</span> <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.unsigned_repr</span> <span class="kwd">in</span> <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;2:{ <span class="tactic">change</span> <span class="id">Int.max_unsigned</span> <span class="kwd">with</span> <span class="id">Ptrofs.max_unsigned</span>; <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span> <span class="kwd">in</span> <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;2:{ <span class="id">lia</span>. }<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hload_ins</span> <span class="kwd">in</span> <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;<span class="tactic">injection</span> <span class="id">Hload</span> <span class="kwd">as</span> <span class="id">Heq</span>; <span class="tactic">subst</span> <span class="id">i0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Int.eq</span> <span class="id">eqn</span>: <span class="id">Heq</span>; [| <span class="tactic">inversion</span> <span class="id">Hsubst</span>].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.same_if_eq</span> <span class="kwd">in</span> <span class="id">Heq</span>; <span class="tactic">subst</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">option_map</span> <span class="kwd">in</span> <span class="id">Hdecode_op</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">decode_thumb</span> <span class="id">eqn</span>: <span class="id">Hdecode_t</span>; <span class="tactic">inversion</span> <span class="id">Hdecode_op</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hexe</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHnl</span> <span class="kwd">with</span> (<span class="id">ofs</span> := <span class="id">ofs</span> + 4) (<span class="id">jit_blk</span> := <span class="id">jit_blk</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">Hsubst</span> <span class="id">Hunchanged</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">code_subset_in_blk_unchange</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">Forward4</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">_bpf_get_call</span>: <span class="id">ident</span> -&gt; <span class="id">genv</span> -&gt; <span class="id">option</span> <span class="id">fundef</span>.<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">backward_from_interpreter_simpl_to_ts</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rs1</span> <span class="id">rs2</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">c</span> <span class="id">kl</span> <span class="id">bl</span> <span class="id">kv</span> <span class="id">l</span> <span class="id">ge</span> <span class="id">jit_blk</span> <span class="id">mrs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">step</span> <span class="id">c</span> (<span class="id">kv_flatten</span> <span class="id">kv</span> (<span class="id">List.length</span> <span class="id">c</span>)) (<span class="id">List.length</span> <span class="id">c</span>) <span class="id">rs1</span> (<span class="id">List.length</span> <span class="id">mrs</span>) <span class="id">mrs</span> <span class="id">m1</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">rs2</span>, <span class="id">m2</span>, <span class="id">BPF_OK</span>) -&gt;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">jit_arm_start_address</span> = <span class="id">Vptr</span> <span class="id">jit_blk</span> <span class="id">Ptrofs.zero</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">l</span> 0 <span class="id">jit_blk</span> <span class="id">m1</span> = <span class="id">true</span> -&gt;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.length</span> <span class="id">c</span> &lt;= <span class="id">MAX_BPF_LIST_INPUT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">analyzer</span> <span class="id">c</span> = <span class="id">Some</span> <span class="id">kl</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">combiner</span> <span class="id">kl</span> = <span class="id">Some</span> <span class="id">bl</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">concat_bin</span> <span class="id">bl</span> = (<span class="id">kv</span>, <span class="id">l</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reg_inv</span> (<span class="id">State</span> <span class="id">rs1</span> <span class="id">m1</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.length</span> <span class="id">l</span> &lt; <span class="id">JITTED_LIST_MAX_LENGTH</span> -&gt;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exists</span> <span class="id">t</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bstep</span> <span class="id">_bpf_get_call</span> (<span class="id">memory_region_mapping</span> <span class="id">mrs</span>) <span class="id">c</span> <span class="id">bl</span> <span class="id">jit_blk</span> <span class="id">ge</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">rs1</span> <span class="id">m1</span>) <span class="id">t</span> (<span class="id">State</span> <span class="id">rs2</span> <span class="id">m2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</div>
<div class="proofscript" id="proof9">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">rs1</span> <span class="id">rs2</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">c</span> <span class="id">kl</span> <span class="id">bl</span> <span class="id">kv</span> <span class="id">l</span> <span class="id">ge</span> <span class="id">jit_blk</span> <span class="id">mrs</span> <span class="id">Hstep</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Hjit_blk</span> <span class="id">Hsubst</span> <span class="id">Hlen_max</span> <span class="id">Hanalyzer</span> <span class="id">Hcombiner</span> <span class="id">Hconcat</span> <span class="id">Hreg_inv</span> <span class="id">Hjit_len_max</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">step</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">eval_ins</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rs1</span> <span class="id">BPC</span>) <span class="kwd">as</span> [|<span class="id">v_pc</span> | <span class="id">v_l</span> | <span class="id">v_f</span> | <span class="id">v_s</span> | <span class="id">v_b</span> <span class="id">v_ofs</span>] <span class="id">eqn</span>: <span class="id">Hpc_eq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hstep</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Int.cmpu</span> <span class="id">eqn</span>: <span class="id">Hlt</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">nth_error</span> <span class="id">eqn</span>: <span class="id">Hnth</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Hpc_eq_nat</span>: <span class="id">v_pc</span> = (<span class="id">Int.repr</span> (<span class="id">Z.of_nat</span> (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>))))). {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">MAX_BPF_LIST_INPUT</span> <span class="kwd">in</span> <span class="id">Hlen_max</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(**r&nbsp;pc1&nbsp;&lt;=&nbsp;List.length&nbsp;c&nbsp;because&nbsp;of&nbsp;find_instr&nbsp;=&nbsp;Some&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Hle_pc</span>: (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>)) &lt; <span class="id">List.length</span> <span class="id">c</span>). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">nth_error_Some</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">HF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">HF</span> <span class="kwd">in</span> <span class="id">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z2Nat.id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;2:{ <span class="tactic">set</span> (<span class="id">Int_unsigned_ge_zero</span> <span class="id">v_pc</span>) <span class="kwd">as</span> <span class="id">Heq</span>. <span class="id">lia</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.repr_unsigned</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">decode_ind</span> <span class="kwd">as</span> [<span class="id">ins</span> | ] <span class="id">eqn</span>: <span class="id">Hdecode</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ins</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">exists</span> <span class="id">E0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Hofs_eq</span>: <span class="id">Ptrofs.to_int</span> (<span class="id">Ptrofs.of_int</span> <span class="id">o</span>) = <span class="id">o</span>). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Ptrofs.to_int_of_int</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Archi.ptr64</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">step_load_x_operation</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">check_mem</span> <span class="kwd">as</span> [<span class="id">ptr</span> |] <span class="id">eqn</span>: <span class="id">Hcheck_mem</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">check_mem_prop</span> <span class="kwd">in</span> <span class="id">Hcheck_mem</span> <span class="kwd">as</span> <span class="id">Hmem</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rBPFValues.cmp_ptr32_null</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.cmpu_bool</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmem</span> <span class="kwd">as</span> [<span class="id">Hmem</span> | <span class="id">Hnull</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;2:{ <span class="tactic">subst</span> <span class="id">ptr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Vnullptr</span>, <span class="id">Archi.ptr64</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmem</span> <span class="kwd">as</span> (<span class="id">blk</span> &amp; <span class="id">ofs</span> &amp; <span class="id">Hptr</span> &amp; <span class="id">Hvalid1</span> &amp; <span class="id">Hvalid2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">ptr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Vnullptr</span>, <span class="id">Archi.ptr64</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hvalid1</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bexec_step_internal_load</span> <span class="kwd">with</span> (<span class="id">v</span> := (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">b</span> := <span class="id">blk</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> &lt;- <span class="id">Hpc_eq_nat</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">find_instr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hdecode</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">exec_load</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">load_mem</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Mem.loadv</span> <span class="id">eqn</span>: <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">sizeOp2chunk</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>; <span class="tactic">clear</span> <span class="id">H0</span>. <span class="tactic">f_equal</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>; <span class="tactic">clear</span> <span class="id">H0</span>. <span class="tactic">f_equal</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>; <span class="tactic">clear</span> <span class="id">H0</span>. <span class="tactic">f_equal</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">sizeOp2chunk</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">exists</span> <span class="id">E0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Hofs_eq</span>: <span class="id">Ptrofs.to_int</span> (<span class="id">Ptrofs.of_int</span> <span class="id">o</span>) = <span class="id">o</span>). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Ptrofs.to_int_of_int</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Archi.ptr64</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">step_store_operation</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s0</span> <span class="kwd">as</span> [<span class="id">src_r</span> | <span class="id">src_i</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">check_mem</span> <span class="kwd">as</span> [<span class="id">ptr</span> |] <span class="id">eqn</span>: <span class="id">Hcheck_mem</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">check_mem_prop</span> <span class="kwd">in</span> <span class="id">Hcheck_mem</span> <span class="kwd">as</span> <span class="id">Hmem</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rBPFValues.cmp_ptr32_null</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.cmpu_bool</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmem</span> <span class="kwd">as</span> [<span class="id">Hmem</span> | <span class="id">Hnull</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:{ <span class="tactic">subst</span> <span class="id">ptr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Vnullptr</span>, <span class="id">Archi.ptr64</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmem</span> <span class="kwd">as</span> (<span class="id">blk</span> &amp; <span class="id">ofs</span> &amp; <span class="id">Hptr</span> &amp; <span class="id">Hvalid1</span> &amp; <span class="id">Hvalid2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">ptr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Vnullptr</span>, <span class="id">Archi.ptr64</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hvalid1</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bexec_step_internal_store</span> <span class="kwd">with</span> (<span class="id">v</span> := (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">b</span> := <span class="id">blk</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> &lt;- <span class="id">Hpc_eq_nat</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">find_instr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hdecode</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">exec_store</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">store_mem</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">eval_reg_imm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Mem.storev</span> <span class="id">eqn</span>: <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">sizeOp2chunk</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>; <span class="tactic">clear</span> <span class="id">H0</span>; <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">sizeOp2chunk</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">check_mem</span> <span class="kwd">as</span> [<span class="id">ptr</span> |] <span class="id">eqn</span>: <span class="id">Hcheck_mem</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">check_mem_prop</span> <span class="kwd">in</span> <span class="id">Hcheck_mem</span> <span class="kwd">as</span> <span class="id">Hmem</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rBPFValues.cmp_ptr32_null</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.cmpu_bool</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmem</span> <span class="kwd">as</span> [<span class="id">Hmem</span> | <span class="id">Hnull</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:{ <span class="tactic">subst</span> <span class="id">ptr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Vnullptr</span>, <span class="id">Archi.ptr64</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmem</span> <span class="kwd">as</span> (<span class="id">blk</span> &amp; <span class="id">ofs</span> &amp; <span class="id">Hptr</span> &amp; <span class="id">Hvalid1</span> &amp; <span class="id">Hvalid2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">ptr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Vnullptr</span>, <span class="id">Archi.ptr64</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hvalid1</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bexec_step_internal_store</span> <span class="kwd">with</span> (<span class="id">v</span> := (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">b</span> := <span class="id">blk</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> &lt;- <span class="id">Hpc_eq_nat</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">find_instr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hdecode</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">exec_store</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">store_mem</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">eval_reg_imm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Mem.storev</span> <span class="id">eqn</span>: <span class="id">Hload</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">sizeOp2chunk</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>; <span class="tactic">clear</span> <span class="id">H0</span>; <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">sizeOp2chunk</span>; <span class="tactic">inversion</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;<br/>
&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">BState.jit_call_simplb</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hpc_eq</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ListNat.index</span> <span class="kwd">as</span> [<span class="id">ofs</span>|] <span class="id">eqn</span>: <span class="id">Hkv_ofs</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exists</span> <span class="id">E0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Hpc_eq1</span>: <span class="id">rs1</span> <span class="id">BPC</span> = <span class="id">Vint</span> (<span class="id">Int.repr</span> (<span class="id">Z.of_nat</span> (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>))))). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Hpc_eq_nat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Hfind</span>: <span class="id">find_instr</span> (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>)) <span class="id">c</span> = <span class="id">Some</span> (<span class="id">Palu32</span> <span class="id">a</span> <span class="id">b</span> <span class="id">s</span>)). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">find_instr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Hdecode</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Heq</span>: <span class="tactic">exists</span> <span class="id">n</span> <span class="id">nl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nth_error</span> <span class="id">bl</span> <span class="id">n</span> = <span class="id">Some</span> (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>), (<span class="id">ofs</span>, <span class="id">nl</span>)) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">code_subset_in_blk</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">m1</span> = <span class="id">true</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_bin_code</span> <span class="id">nl</span> <span class="id">ofs</span> <span class="id">jit_blk</span> <span class="id">rs1</span> <span class="id">m1</span> = <span class="kwd">Next</span> <span class="id">rs2</span> <span class="id">m2</span> ). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">exec_bin_code</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Mem.alloc</span> <span class="kwd">as</span> (<span class="id">m3</span> &amp; <span class="id">st_blk</span>) <span class="id">eqn</span>: <span class="id">Halloc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">copy_to</span> <span class="kwd">as</span> [<span class="id">m4</span> | ] <span class="id">eqn</span>: <span class="id">Hcopy_to</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">bin_exec</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hjit_blk</span> <span class="kwd">in</span> <span class="id">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.unsigned_repr</span> <span class="kwd">in</span> <span class="id">Hstep</span>; [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="tactic">unfold</span> <span class="id">stack_block_size</span>; <span class="tactic">change</span> <span class="id">Int.max_unsigned</span> <span class="kwd">with</span> 4294967295%<span class="id">Z</span>; <span class="id">lia</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">init_state</span> <span class="kwd">as</span> [<span class="id">rs</span> <span class="id">stk</span> <span class="id">stkb</span> <span class="id">m5</span> |] <span class="id">eqn</span>: <span class="id">Hinit</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">kv_flatten_property</span> <span class="kwd">in</span> <span class="id">Hkv_ofs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hkv_ofs</span> <span class="kwd">as</span> (<span class="id">nl</span> &amp; <span class="id">HIn</span> &amp; <span class="id">Hsubst1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">In_nth_error</span> <span class="kwd">in</span> <span class="id">HIn</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">HIn</span> <span class="kwd">as</span> (<span class="id">n</span> &amp; <span class="id">HIn</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exists</span> <span class="id">n</span>, <span class="id">nl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; [<span class="tactic">assumption</span> | ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; [<span class="tactic">assumption</span> | ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">bin_interp</span> <span class="kwd">as</span> [(<span class="id">res</span> &amp; <span class="id">m6</span>) | ] <span class="id">eqn</span>: <span class="id">Hinterp</span>; [| <span class="tactic">inversion</span> <span class="id">Hstep</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bin_interp_less_fuel</span> <span class="kwd">with</span> () <span class="kwd">in</span> <span class="id">Hinterp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bin_interp_exec_bin_list</span> <span class="kwd">in</span> <span class="id">Hinterp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;../..<br/>
<br/>
<br/>
&nbsp;*)<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">admit</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span> <span class="kwd">as</span> (<span class="id">n</span> &amp; <span class="id">nl</span> &amp; <span class="id">Hnth1</span> &amp; <span class="id">Hsubst1</span> &amp; <span class="id">Hexe1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bexec_step_alu32</span> <span class="kwd">with</span> (<span class="id">v</span> := (<span class="id">Z.to_nat</span> (<span class="id">Int.unsigned</span> <span class="id">v_pc</span>))) (<span class="id">ofs</span> := <span class="id">ofs</span>); <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;- <br/>
Qed.</div>
<span class="kwd">End</span> <span class="id">Forward4</span>.
</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</a></div>
</body>
</html>
